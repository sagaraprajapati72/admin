// components/EditBookModal.tsx
"use client";

import React, { useEffect, useState } from "react";
import {
  Modal,
  ModalOverlay,
  ModalContent,
  ModalHeader,
  ModalCloseButton,
  ModalBody,
  ModalFooter,
  Button,
  FormControl,
  FormLabel,
  Input,
  useToast,
  FormErrorMessage,
  VStack,
} from "@chakra-ui/react";
import { useForm, Controller } from "react-hook-form";
import Select from "react-select";
import AsyncSelect from "react-select/async";
import dynamic from "next/dynamic";
import { useRouter } from "next/navigation";
const ReactQuill = dynamic(() => import("react-quill-new"), { ssr: false });
import "react-quill/dist/quill.snow.css";

export type Option = { value: number | string; label: string };


type BookFormData = {
  title: string;
  isbn: string;
  authors: Option[];
  audiences: Option[];
  summary: string;
  language: Option | null;
  publicationDate: string;
  publisher: string;
  price: number;
  keywords: string;
  genre: Option[];
  category: Option | null;
};

type Props = {
  isOpen: boolean;
  onClose: () => void;
  bookId: number | null;
};

export default function EditBookModal({ isOpen, onClose, bookId }: Props) {
  const {
    handleSubmit,
    register,
    control,
    setValue,
    getValues,
    formState: { errors },
  } = useForm<BookFormData>();

  const toast = useToast();
  const [genres, setGenres] = useState<Option[]>([]);
  const [languages, setLanguages] = useState<Option[]>([]);
  const [audiences, setAudiences] = useState<Option[]>([]);
  const [categories, setCategories] = useState<Option[]>([]);
  const [generating, setGenerating] = useState(false);
  const [generatingKeywords, setGeneratingKeywords] = useState(false);
  const router = useRouter();
  const fetchAuthors = async (input: string): Promise<Option[]> => {
    const res = await fetch(`/api/public/authors?search=${input}`);
    const data = await res.json();
    return data.map((a: any) => ({ value: a.id, label: a.name }));
  };

  const fetchDropdowns = async () => {
    const fetchOptions = async (url: string, mapFn: any) => {
      const res = await fetch(url);
      const data = await res.json();
      return data.map(mapFn);
    };

    const [g, l, a, c] = await Promise.all([
      fetchOptions("/api/public/genres", (i: any) => ({ value: i.id, label: i.name })),
      fetchOptions("/api/public/languages", (i: any) => ({ value: i.id, label: i.name })),
      fetchOptions("/api/public/audiences", (i: any) => ({ value: i.id, label: i.targetGroup })),
      fetchOptions("/api/public/categories", (i: any) => ({ value: i.id, label: i.name })),
    ]);

    setGenres(g);
    setLanguages(l);
    setAudiences(a);
    setCategories(c);
  };
  const handleAutoGenerateDescription = async () => {
    const title = getValues("title");
    const authors = getValues("authors");
    if (!title) {
      toast({ title: "Missing Title", description: "Enter title first.", status: "warning" });
      return;
    }

    const authorName = authors?.map((a) => a.label).join(", ") || "";

    setGenerating(true);
    try {
      const res = await fetch("/api/genai/book-descriptions", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ title, authorName }),
      });
      const data = await res.json();
      setValue("summary", data.description, { shouldDirty: true });
      toast({ title: "Generated", description: "Summary added.", status: "success" });
    } catch (err: any) {
      toast({ title: "Error", description: err.message, status: "error" });
    } finally {
      setGenerating(false);
    }
  };

  const handleAutoGenerateKeywords = async () => {
    const title = getValues("title");
    const summary = getValues("summary");
    const authors = getValues("authors");

    if (!title || !summary) {
      toast({
        title: "Missing Info",
        description: "Enter title & summary first.",
        status: "warning",
      });
      return;
    }

    const authorName = authors?.map((a) => a.label).join(", ") || "";

    setGeneratingKeywords(true);
    try {
      const res = await fetch("/api/genai/book-keywords", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ title, authorName, summary }),
      });
      const data = await res.json();
      setValue("keywords", data.keywords, { shouldDirty: true });
      toast({ title: "Generated", description: "Keywords added.", status: "success" });
    } catch (err: any) {
      toast({ title: "Error", description: err.message, status: "error" });
    } finally {
      setGeneratingKeywords(false);
    }
  };

  const fetchBook = async () => {
    if (!bookId) return;
    const res = await fetch(`/api/public/books/${bookId}`);
    const book = await res.json();

    setValue("title", book.title);
    setValue("isbn", book.isbn);
    setValue("publisher", book.publisher);
    setValue("publicationDate", book.publishDate);
    setValue("price", book.price);
    setValue("summary", book.summary);
    setValue("keywords", book.keywords);
    setValue("authors", book.authors.map((a: any) => ({ value: a.id, label: a.name })));
    setValue("genre", book.genres.map((g: any) => ({ value: g.id, label: g.name })));
    setValue("audiences", book.audiences.map((a: any) => ({ value: a.id, label: a.targetGroup })));
    setValue("language", { value: book.language.id, label: book.language.name });
    setValue("category", { value: book.category.id, label: book.category.name });
  };

  useEffect(() => {
    if (isOpen && bookId) {
      fetchDropdowns();
      fetchBook();
    }
  }, [isOpen, bookId]);

  const onSubmit = async (data: BookFormData) => {
    if (!bookId) return;
    const payload = {
      title: data.title,
      isbn: data.isbn,
      publisher: data.publisher,
      publicationDate: data.publicationDate,
      price: data.price,
      summary: data.summary,
      keywords: data.keywords,
      genreIds: data.genre.map((g) => g.value),
      authorIds: data.authors.map((a) => a.value),
      audienceIds: data.audiences.map((a) => a.value),
      languageId: data.language?.value,
      categoryId: data.category?.value,
    };

    const res = await fetch(`/api/admin/books/${bookId}`, {
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload),
    });

    if (res.ok) {
      toast({ title: "Book updated successfully", status: "success" });
      onClose();
      router.push("/books/edit"); // ðŸ‘ˆ Replace this with your actual search/edit page route
    }
    else {
      toast({ title: "Update failed", status: "error" });
    }
  };

  return (
    <Modal isOpen={isOpen} onClose={onClose} size="4xl">
      <ModalOverlay />
      <ModalContent>
        <ModalHeader>Edit Book</ModalHeader>
        <ModalCloseButton />
        <ModalBody>
          <form onSubmit={handleSubmit(onSubmit)}>
            <VStack spacing={4}>
              <FormControl isInvalid={!!errors.title}>
                <FormLabel>Title</FormLabel>
                <Input {...register("title", { required: "Required" })} />
                <FormErrorMessage>{errors.title?.message}</FormErrorMessage>
              </FormControl>

              <FormControl isInvalid={!!errors.authors}>
                <FormLabel>Authors</FormLabel>
                <Controller
                  name="authors"
                  control={control}
                  render={({ field }) => (
                    <AsyncSelect
                      isMulti
                      cacheOptions
                      defaultOptions
                      loadOptions={fetchAuthors}
                      {...field}
                    />
                  )}
                />
                <FormErrorMessage>{(errors.authors as any)?.message}</FormErrorMessage>
              </FormControl>

              <FormControl isInvalid={!!errors.isbn}>
                <FormLabel>ISBN</FormLabel>
                <Input {...register("isbn", { required: "Required" })} />
                <FormErrorMessage>{errors.isbn?.message}</FormErrorMessage>
              </FormControl>

              <FormControl isInvalid={!!errors.publisher}>
                <FormLabel>Publisher</FormLabel>
                <Input {...register("publisher", { required: "Required" })} />
                <FormErrorMessage>{errors.publisher?.message}</FormErrorMessage>
              </FormControl>

              <FormControl isInvalid={!!errors.publicationDate}>
                <FormLabel>Publication Date</FormLabel>
                <Input type="date" {...register("publicationDate", { required: "Required" })} />
                <FormErrorMessage>{errors.publicationDate?.message}</FormErrorMessage>
              </FormControl>

              <FormControl isInvalid={!!errors.price}>
                <FormLabel>Price</FormLabel>
                <Input type="number" {...register("price", { required: "Required" })} />
                <FormErrorMessage>{errors.price?.message}</FormErrorMessage>
              </FormControl>

              <FormControl isInvalid={!!errors.language}>
                <FormLabel>Language</FormLabel>
                <Controller name="language" control={control} render={({ field }) => <Select options={languages} {...field} />} />
                <FormErrorMessage>{errors.language?.message}</FormErrorMessage>
              </FormControl>

              <FormControl isInvalid={!!errors.category}>
                <FormLabel>Category</FormLabel>
                <Controller name="category" control={control} render={({ field }) => <Select options={categories} {...field} />} />
                <FormErrorMessage>{errors.category?.message}</FormErrorMessage>
              </FormControl>

              <FormControl isInvalid={!!errors.genre}>
                <FormLabel>Genres</FormLabel>
                <Controller name="genre" control={control} render={({ field }) => <Select isMulti options={genres} {...field} />} />
                <FormErrorMessage>{errors.genre?.message}</FormErrorMessage>
              </FormControl>

              <FormControl isInvalid={!!errors.audiences}>
                <FormLabel>Audiences</FormLabel>
                <Controller name="audiences" control={control} render={({ field }) => <Select isMulti options={audiences} {...field} />} />
                <FormErrorMessage>{(errors.audiences as any)?.message}</FormErrorMessage>
              </FormControl>

              <FormControl isInvalid={!!errors.summary}>
                <FormLabel>Summary</FormLabel>
                <Button
                  onClick={handleAutoGenerateDescription}
                  size="sm"
                  mb={2}
                  colorScheme="blue"
                  isLoading={generating}
                >
                  Auto Generate Description
                </Button>
                <Controller
                  name="summary"
                  control={control}
                  render={({ field }) => (
                    <ReactQuill value={field.value || ""} onChange={field.onChange} />
                  )}
                />
                <FormErrorMessage>{errors.summary?.message}</FormErrorMessage>
              </FormControl>

              <FormControl isInvalid={!!errors.keywords}>
                <FormLabel>Keywords</FormLabel>
                <Button
                  onClick={handleAutoGenerateKeywords}
                  size="sm"
                  mb={2}
                  colorScheme="blue"
                  isLoading={generatingKeywords}
                >
                  Auto Generate Keywords
                </Button>
                <Input {...register("keywords", { required: "Required" })} />
                <FormErrorMessage>{errors.keywords?.message}</FormErrorMessage>
              </FormControl>

            </VStack>
            <ModalFooter px={0} mt={6}>
              <Button colorScheme="blue" mr={3} type="submit">
                Save
              </Button>
              <Button onClick={onClose}>Cancel</Button>
            </ModalFooter>
          </form>
        </ModalBody>
      </ModalContent>
    </Modal>
  );
}
